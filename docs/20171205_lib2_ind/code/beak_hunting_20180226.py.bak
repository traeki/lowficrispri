#!/usr/bin/env python

# Author: John Hawkins (jsh) [really@gmail.com]
import itertools
import logging
import matplotlib.pyplot as plt
import numpy as np
import os.path
import pdb
import pandas as pd
import seaborn as sns
import scipy.stats as st
import sys

from sklearn.decomposition import PCA

import global_config as gcf
import sklearn_preproc as prep

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')

PREFIX = os.path.splitext(os.path.basename(__file__))[0]

QUESTION = '''
Where is this beak coming from?
'''

# <NO_EDIT>
statout = os.path.join(gcf.OUTPUT_DIR, '.'.join([PREFIX, 'stats']))
graphout = os.path.join(gcf.OUTPUT_DIR, '.'.join([PREFIX, 'svg']))
graphflat = os.path.join(gcf.OUTPUT_DIR, '.'.join([PREFIX, 'png']))
notesout = os.path.join(gcf.OUTPUT_DIR, '.'.join([PREFIX, 'notes']))

diffdatafile = os.path.join(gcf.OUTPUT_DIR, 'lib234.diffdata.tsv')
diffdata = pd.read_csv(diffdatafile, sep='\t', header=0)
solodatafile = os.path.join(gcf.OUTPUT_DIR, 'lib234.data.tsv')
solodata = pd.read_csv(solodatafile, sep='\t', header=0)

# Output notes
with open(notesout, 'w') as f:
  f.write(QUESTION.format(**vars()))
# </NO_EDIT>


#############

# Compute expected SD = f = splinefit(mean(variant), SD(variant))
# Divide SD(variant) by f(variant)
# Result: how many standard deviations away from its own average the variant is.
# Problem: "mean" isn't scaled according to fitness relationships between axes.

# Two PCA-related ideas
# 1) Plot points in old-style graphs based on each PCA score for PC[1-10]
# 2) Plot points in old-style graphs after mapping into and out of first k
#    PCs.  When does the beak manifest?
# 2 sounds easier...

prepped = prep.prep_for_sklearn(diffdata)
# minimal = prep.remove_overlapping(prepped)

genemap = diffdata.set_index('variant').gene_name
genemap = genemap.reset_index().drop_duplicates().set_index('variant')

plotsets = list()
plotsets.append(('a0d1', 'a2d1'))
plotsets.append(('b0d1', 'b2d1'))
plotsets.append(('c0d1', 'c2d1'))
plotsets.append(('a0d2', 'a2d2'))
plotsets.append(('a0d3', 'a2d3'))

# rows = len(plotsets)
# cols = len(plotsets)
# gsize = 4
# sizes=5
# (start, stop) = (-1.6, 0.3)

for depth in range(1, 10+1):
  logging.info('Doing PCA round-trip for depth {depth}.'.format(**vars()))
  pca = PCA(n_components=depth)
  pca.fit(prepped)
  axisnames = ['PC{0}'.format(i) for i in range(1, depth+1)]
  pca_warped = pca.transform(prepped)
  pca_warped = pd.DataFrame(pca_warped,
                            columns=axisnames, index=prepped.index)
  pca_smoothed = pca.inverse_transform(pca_warped)
  pca_smoothed = pd.DataFrame(pca_smoothed,
                              columns=prepped.columns, index=prepped.index)
  # fig, axes = plt.subplots(rows, cols, figsize=(gsize*cols,gsize*rows),
  #                          sharex='col', sharey='row')
  logging.info('Building figure for depth {depth}.'.format(**vars()))
  sns.pairplot(pca_smoothed[plotsets])
  # for i, ycol in enumerate(plotsets):
  #   for j, xcol in enumerate(plotsets):
  #     pdb.set_trace()
  #     ax = axes[i, j]
  #     ax.plot([start, stop], [start, stop], 'b--', linewidth=.5)
  #     leftname = '_'.join(xcol)
  #     rightname = '_'.join(ycol)
  #     logging.info(
  #         'Plotting {leftname} vs {rightname} on {i}, {j}'.format(**vars()))
  #     ax = sns.regplot(xcol, ycol, data=pca_smoothed, fit_reg=False, ax=ax,
  #                      scatter_kws=dict(s=sizes, alpha=0.2, color='magenta'))
  #     ax.set_xlim(start, stop)
  #     ax.set_ylim(start, stop)
  #     ax.set(xlabel='gamma [' + leftname + ']')
  #     ax.set(ylabel='gamma [' + rightname + ']')
  #     ax.label_outer()

  plt.suptitle(
      'gammas, pairwise plots [No Drug], PC1-{depth}'.format(**vars()),
      fontsize=16)
  # fig.subplots_adjust(hspace=0, wspace=0)
  depthflat = os.path.join(
      gcf.OUTPUT_DIR, '.'.join([PREFIX, 'pcsmooth', str(depth), 'png']))
  logging.info('Writing flat graph to {depthflat}'.format(**vars()))
  plt.savefig(depthflat)
  plt.clf()
